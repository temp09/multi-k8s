Hello and welcome to Keys, Certificates, Keystores and TLS. This section will cover an introduction to TLS and introduce the basics needed to prepare for implementing TLS on Edge. All the security modules refer to certificates, keys, and keystores. The short module will cover the basics of creating each of these elements. Over the next few minutes, we'll cover TLS and SSL, private keys, certificates and certificates sign and requests, and finally, Java Keystores. TLS, Transport Layer Security, and its predecessor, Secure Sockets Layer, SSL, are both cryptographic protocols designed to provide communications security over a computer network. The terms SSL and TLS are often used interchangeably or in conjunction with each other. In fact, SSL 3.0 actually saw it as a basis for TLS 1.0. TLS is the standard security technology that we will use for ensure and secure encrypted messaging across your API environment from apps to Apigee Edge to your back-end services. Edge supports one-way TLS and two-way TLS in both our cloud and on-premise deployments. One-way TLS enables a TLS client to verify the identity of the TLS server. For example, an app running on your Google Pixel phone, the client can verify the identity of the Edge Gateway serving your APIs. We can see the initial hello from the client application being sent to the server, application B. The server then sends it certificate. The client is then able to verify the server credentials based on that certificate. With two-way TLS or SSL, the client application verifies the server application identity. The server then verifies the client applications identity. This is often called client or mutual TLS because the client identifies itself once the TLS server application has authenticated itself to the client. With this process, a client requests access to a protective resource. The server then presents its certificate to the client. The client verifies the server certificate. If successful, the client then sends its certificate back to the server. The server then verifies the client's credentials. If successful, the server grants access to the protective resource requested by the client. Next, we come on to private keys. Private keys are used to identify the server. They're necessary both when creating certificate requests as well as when creating keystores and truststores. Private keys should be kept in a secure location on the server. In this case, we've created a directory that matches the F key at the end of the server. Next, we change the permissions to 700. Only we have permission to this directory. Everybody else is blocked. Finally, we can create and secure the key. Hopefully, you're familiar with OpenSSL. The commands shown creates an RSA key, genrsa. It sets the final name and the path of the new key, private.pen in this case. It specifies the key length to be 2,048. And finally, we can secure the key by setting the permissions to 600. Before our application can securely solve traffic, we need to supply it with a trusted certificate to identify itself. Onscreen, we can see that we are going to create a Certificate Signing Request so that we can solve traffic for https: //tlsdemo.apigee.google.com. To do this, we create a sign request, again using OpenSSL, but also using the private key we created earlier. The command sets the action to request, req, minus new, TLS, OpenSSL. Well, this is a new request. Minus key, here we set the path to the private key we created earlier. Minus out, tell us OpenSSL where to write the request and does subj, search the certificate's information. Here, we set the country, state, locality, organization and finally, the F key DN for the certificate. This creates a certificate sign in request that can be sent to your certificate authority to generate the signed trusted certificate. Before applying your new certificate, you should check that it matches the private key you used to create the request. To do this, you can run the two commands shown. Each will return the modulus of the certificates okay, both return values should be exactly the same. In Edge, we mostly need to use Java Keystores when securing our applications. When we create keystores, it is good practice to give the keystore an easily identifiable alias. First, we again use the OpenSSL tool and private key, but this time, we're also using our signed certificates. We supply OpenSSL with the keystore type we want to use. We give it the action exporting, the type sales certs, and the path to the certificate. We can supply the private key, a path to the exported keystore and finally, an alias by which to reference it. Once the keystore has been created, we can then use the Java keytool utility to convert it to a JKS formats. The options here are fairly straightforward. Import keystore, I will begin with the path to the source keystore, the one we just created. A type of keystore for the source, a path or a final JKS keystore, and we set the type to JKS. And the last thing, we give an alias of port API to identify it, and that we'll use later. This concludes a refresher for certificates, keystores, private keys, and TLS. For more information, you can visit docs.apigee.com. And to get involved in the community, please go the community.apigee.com. Thank you.