In this lab, you configured an HTTP load
balancer with backends in your central one and your request one. Then you stress tested the load
balancer with a VM, and blacklisted the IP address
off that VM with Cloud Armor. Finally, you were able to
explore the security policy logs to identify why the traffic was blocked. Let me walk you through the lab. Now, keep in mind that GCP's
user interface can change. So your environment might
look slightly different. So here I am in the GCP console. Now, the first thing I want to do is, I
want to create a firewall rule to actually allow HTTP traffic for
my HTTP load balancer. So let me head over to
the firewall rules section, and click on create a firewall rule. I'm going to give the firewall rule
a name and I'm actually going to use specified target tags here, and
just tie this to http-server. So this way any instances
that have this target tag will have this firewall rule applied, too. As for the source ranges, I'm going to
log connections from anywhere. And then I just need to
specify the protocol and port, which for HTTP is tcp80. So let me go ahead and create that. All right, so now we can see that
the firewall rule has been created. Now, I want to go a head and
create another firewall rule. And this one is for the health checks,
and the health checks determine which instances of the load balancer
can receive new connections. So this is a pretty important one. Let me go create another firewall rule. We copy over the name from the lab manual. And I'm also going to
use the target tag here to make sure that I only apply this to
the instances that are part of my backend. Now, the source IP ranges for
this are listed in the documentation as well as the lab, so
I'm just going to paste these here. And the important thing here is you
want to maybe paste them one by one and I have this space in between so that they actually get registered
as two separate IP addresses. So there we go. Now, the protocol,
I'm just going to type TCP and that means I'm allowing all
ports on the TCP protocol. So I'm going to click Create for
this one, too. So now that this firewall has been
created, I'm going to go ahead and configure the instance templates and
instance groups, and I do that within Compute Engine. So this is very similar to actually
creating instances, but the difference is that I'm actually just providing a recipe
for how those instances should be created. And then the instance group itself
will manage the instances for me. So let me go and
click Create instance template, And I'm going to collapse this to get
a little bit more space here. And I'm just going to type
the name us-central1-template. I'm going to leave the machine type as is. And then we can expand
the section down here and under Management,
I'm now going to define some metadata. And specifically what I'm going to do is,
I'm going to define a startup script. And this is going to install the web
server, and you can go to this location. This is just from a cloud storage bucket. And if you want you could look at this,
but we'll see this in action in just a second. Now, the other thing I'm going to do
is I'm going to go to Networking. And in here, I want to make sure that under the network
interface I specify my target tag. So this is going to be for
the http server. And that way all these instances will have
those two file rules that we just created. So let me go ahead and create that. All right, so now I can go ahead and
create another one. And the easiest way to do that is, I'm actually going to take
the existing instance group here and I'm going to click the copy button to have
most of these settings already applied. I'm just going to rename this to the europe-west1-template. And I'm going back to management
security disks, and because I copied, I already have the startup script for
these instances as well And for networking, I'm going to select the europe-west1 network. And then I'm going to just
click Create on that as well. So now that I've created my
managed instance templates, I'm going to create groups
from these templates. There are two ways I could do this. I can actually do this from the template,
or I can navigate to the Instance Groups pane and then just from here
create an instance group. I'm going to give it a name. I'm first creating the one for
us-central1. And this will be a multi-zone,
specifically to us-central1. And I'm going to have it use
the us-central1 template. And then I can define some autoscaling. So I want this target CPU usage to be 80%. Anything higher will spawn more instances. I want to start off with
at least an instance and I don't want to exceed five instances. And this really is to sort of help
you cover your costs a little bit. You don't want to set this to 100 and
then you just have 100 instances running. This Cool-down period here helps
define the time after which the autoscale will actually
check on the CPU usage. And the reason I do that is when
you first launch these instances, it's going to install the startup script. And during that time,
there may be a higher CPU usage. So I want to kind of ignore
that initial time frame. So I'm going to go ahead and click Create. And while it is being created,
I can go ahead and start on the next one. So now I'm going to create
the instant group for europe west. This is also going to be a multi-zone, but in this case I'm going to
choose the europe-west zone. I'm going to pick my instance template. And somewhat for the autoscaling, I'm just going to define
these same Target CPU usage. Maximum number of instance and
cool down period. Let me go ahead and Create that as well. So you can see that the us-central1
group is already done. And I'm actually going to head over
now to my Compute Engine instances. And here I can already see us-central1,
and shortly the europe-west1 instance
will show up here, as well. Now, what I want to do is I
want to show you the effect of the startup script that we installed. So what I'm going to do now is I'm just
going to click in the external IP of this instance, and
this is going to open a new tab. It looks like it's not quite ready yet. So we might have to wait a little bit for
that startup script to install. So let me just refresh that. Okay, looks like the server is
about to come up, and there we go. So we can see that the instance itself
mentions the lab running, mentions my IP. It has the hostname and
with that we can identify that this is a instance in us-central1 and
it even gives me the exact location. Now, the reason I'm doing that is
that when we use the load balancer, I want to know which backend
instance I'm actually reaching. So if I come back here, we see
europe-west1 is also up and running. And if I click on
the external IP address here, we can see that this instance
is in a different region and zone as expected, because it's
from the different instance group. Then again,
that's purely going to help us for the HTTP load balancer to identify
where traffic is being sent to. So let's go ahead and
create that load balancer. So I'm going to go back to
the navigation menu, and I'm going to go down to Networking,
specifically this is a network service. I'm going to create a load balancer, and
specifically the HTTP(S) Load Balancer. So I'm going to click on Start
configuration, I'm just going to give the load balancer itself a name,
http-lb, and now I have to go through
this configuration here. So I start with the Backend configuration,
and specifically I'm going to
create a backend service. I'm going to give that
backend service also a name. I could modify the Protocol and
the Timeout. I'm going to leave these settings. And now I define the instance
groups that I just created. So first, I'm going to pick the
us-central1 on port 80, that's for HTTP. I'm going to leave that, but I'm going to
modify the Balancing mode to Rate. So you see,
we have two options here, so for this one I'm going to pick 50 requests
per second and leave the capacity at 100. So this configuration means
that the load balancer tends to keep each instance of us-central1-mig
at or below 50 requests per second. So I'm going to click Done and then I'm going to add the other backend,
which is our europe-west backend. In this case I'm actually going to
leave this to the CPU utilization, and click Done. Now I do want to create a health check,
and this is going to ensure that the instances are up and
running that I'm sending traffic to. So I just define us a name,
and have a check on port 80. And that's really all I need to do here. And what it's going to do specifically
given the current configuration is the health check is going to pull
instances every five seconds, waits up to five seconds for a response,
and treats two successful or two failed attempts as healthy or
unhealthy respectively. So let me save that and
then we're going to click Create. Now there are also host path
rules that you can define, these are very powerful but I'm not
going to leverage these in this lab. Instead I'm going to the Frontend
configuration, I want to make sure this is an HTTP load balancer using
an IPv4 address, Ephemeral port 80. I'll click Done, and
I can also add an IPv6 address if I want. As simple as just adding another
frontend and defining IPv6. So there you go. And now I'm going to click Review and
finalize. I can go through all these
settings that I've enabled so far. I see my host and path rules, and I see
my two frontends that I've configured. So let me go ahead and click Create,
and we're going to wait for this now to be created. So here we are,
the load balancer has been created. And now I'm going to go click on it to get
the IPv4 address off this load balancer. So this is the IPv4 address,
here's also the IPv6 address. So let me go ahead and
take the IPv4 address. I'm just going to create a new tab and
navigate to that address. Now, when I do so,
I may not be able to reach this quite yet. So here see I actually get a 404 error,
and that's because it takes a couple of minutes to access the HTTP
bitload balancer. So in the meantime you can get this 404,
or if I refresh we might
even get a 502 error. So I'm going to wait a little bit and
try to refresh every minute or so until I'm able to see the page
of one of the backends. All right, so here we are,
I've refreshed the page a couple times. And I'm actually currently closest
to the us-central1 backend. So this is the backend that I'm reaching. And again, very similar to
the page we looked at before, but now we're directing traffic through
this load balancer IP address. Now I also configured a IPv6 IP here, and I actually have access to IPv6 for
my current location. And I can show you what that looks like,
in case you don't. Here we go, just had to refresh it. And there we can see that I can also use
the IPv6 address as well as the IPv4 address to reach my backends. So what I want to do now is I want to
stress test this load balancer. So I'm going to go ahead and
I'm going to close some of these tabs. And I want to create another VM, and we're
going to use that VM to access the load balancer a lot of times, and
we'll see what happens with the backends. So let me go to Compute Engine, and
we're going to create a new instance. And give that a name, calling it siege because that's the tool
that we're going to install in it. I'm going to locate it in us-west1. And I'm doing that to specifically have
traffic come to us-central1 if possible. So we should see that traffic line there,
and I'm just going to go ahead and click Create. I'm going to wait for
that to be created, and then I'm going to install
some software on this VM. So now that it's installed
I'm going to SSH in here. I'm just waiting for the keys to transfer to the VM to
establish an SSH connection here. All right, so here we go. I'm going to pass the command
to install siege. And once that is done, I'm going to export
the IP address and store that in here. So let me go back and
grab that from my load balancer. Just going to go back to Network
services > Load balancing, And this is the IP address
that I want to store. And then I'm going to go ahead and,
Put that in there. Just resizing my window a little bit. And now I'm going to use
the siege command to essentially launch an attack on this HTTP address. All right, so
this is the expected output here. And now what I'm going to do is I'm
going to navigate to the backend, And we're going to click on backends,
and backend itself. And here we can monitor the backend. So we see out two backends, and
we see where our traffic is coming from. And as we get a lot of traffic, this is actually going to visualize
where the traffic ends up. So what I'm going to do is I'm
going to wait here for about two or three minutes until I
start seeing some traffic. So here I am now, I can see the visualized
traffic coming from my instance at 25 requests per second, and it's
currently going to my us-central1 backend. And if I were to increase this, I would
also see some going to europe-west1. And you may see this if we stick around
here long enough and refresh this, we'll actually see traffic going to
all of these different backends. So let me go ahead and
stop the siege itself. And what I want to do now is I want
to block the IP address of this siege server using Cloud Armor. So let me go ahead and
navigate to Cloud Armor. And before I do,
I need the IP address of the Siege server. And so you may ask yourself,
well how would I find that out? Usually I'm not going to
attack my own infrastructure, how would I find out the IP
address of a different server? Well for that you could use
a feature called VPC flow logs, which we're going to cover in
a later module in this course. So I have the IP address, and now I am
going to navigate to network security. And within that I am
going to pick a cloud armor. Now I need to create a policy. I'm just going to define out a name. I want to blacklist the Siege server. Now the default rule, I'm going to
define is allow, and what this means is all traffic will be allowed,
except for what I have blacklisted. Alternatively, I could deny all traffic,
and just whitelist specific traffic. You go to Next Step and add a rule. Now in this rule, I'm going to define
the exact IP address that I want to block. I just copy that, and I want to deny this
and I can even choose a specific error. In this case I'm going to
have it use a 403 Forbidden. And so I am going to click done,
Next step. I forgot to enter
the deny enable priority. So I need to define the priority,
click Done. Now I'm going to go to the next step and
add the target. So this now defines where
does this get applied to, and this works on load balancer. So let me apply this to my HTTP
load balancer, click Done, and now I'm going to click Create Policy. Okay so now the policy has been created,
I'm going to go back to my C server and I'm going to check these policies in
effect by trying to curl the IP address of that load balancer. And you'll see that I
actually get a response. That's because it actually
takes some time, for the security policy to take effect. So let me wait here a little bit and try
to access this again in a couple minutes. All right, so here I am,
you can see I've curled the IP address and I was still getting the web server and
now I just called that again, and I get the 403 Forbidden error. This exactly what I had specified. Now, I just want to show you that
you can still access the server, specifically load balancer,
from somewhere else. So here I still have the load balancer,
and from my browser, I can still access, because I only
blacklisted a specific IP address and allowed traffic from everywhere else. So let me now try to place
a load on here again and I want to copy in the command that
creates another siege on this IP address. And when you do this,
you might say hey wait, I thought you saw that this
is going to be blocked now, but the command here seems like
it's actually gone through. Well let's go into the logs
of the security policy. So I'm going to go click
on blacklist siege, and click on logs to view the policy logs. So all the logs are going to be
stored here around this policy, and the second I come in here you
see that I'll actually have, if I load some of these logs,
a lot of requests. And these are currently
coming from my Siege VM. And I can get more information about
that by expanding the jsonPayload and seeing that for whatever reason
this specific traffic was denied. And if I go into the HTTP request,
you'll see the actual remote IP of where I'm
trying to access this from. So currently the access here is denied, because of the security
policy that I configured. And so you can explore these logs to
determine when traffic is denied and when it's allowed,
along with these source of the traffic. All right, that's it,
that's the end of the lab.