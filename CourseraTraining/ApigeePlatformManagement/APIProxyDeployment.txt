Hello and welcome to Apigee Edge Management: API Proxy Deployment. Today, we're going to talk about API proxy deployment, API proxy imports and export, and API proxy deployment and SDLC integration. So, deploying an API proxy. An API proxy is part of an organization. When you create or import a proxy, it is placed logically within the boundary of the organization you specify. At this point, the proxy exists but cannot be used. In our example, we have an environment called dev. When we deploy an API proxy to the dev environment, we are creating a logical association between the API proxy revision and the environment that we specify. A revision is simply a snapshot of the proxy code. At this point, the proxy is available to serve traffic. In the final part of this example, we also want to deploy the API proxy to the QA environment. Deploying the API proxy to another environment does not actually involve any movement of code artifacts. An API proxy revision can be deployed to multiple environments within the same organization simultaneously. In this example, we have a second organization, Org B, and we would like to deploy an API proxy from Org A into the dev environment in Org B. In Edge, an organization represents a tenant. Organizations are hard logical boundaries and drive strong separation of assets. For this reason, to deploy a proxy owned by Org A to Org B, we need to first export that proxy from Org A, import the proxy to Org B, and then deploy the proxy to the dev environment in Org B. The same process applies equally to two organizations regardless of whether they reside within the same planet or on two separate planets. API proxy deployment and other tasks doesn't require new tools. Many Edge customers choose to use their existing investments and tool chain Git, Jenkins, Mavens, et cetera, when managing the API proxies. On screen, you can see how CICD tools can be used with Apigee. Proxies are exported from the non-prod planet. Next, they are committed to source control whether retrieved by the CI server. This can trigger deployments which can then be managed by the build or deploy tool. This would have two stages, the first stage being the input to the proxy into production, the second being the actual deployment to the API proxy to the specified environment. It's important to remember that a deployment may be composed of more than just API proxies. Target servers, cache, and KVM definitions as well as API products, et cetera, may well need to be promoted between organizations and environments. As it we discovered in the last lesson, Apigee provides tools to assist in this process. When designing your deployment processes, it is important to understand the scope of all the resources and the dependencies. Here, you can clearly see which objects exist at the organization level, users roles, companies, API products, et cetera, as well as those that can be scoped at an environment level, target servers, deployments, cash resources, et cetera. Again, being an API company, you can use APIs to get information about API proxies present in your organization. In this example, we're listing all the APIs. The call is made against the management server on port 8080, passing in the name of the organization. We can see when run against the validate organization that we have three API proxies returned: smartdocs, healthcheck, and passthrough. Now, we have a list of available API proxies we can explore them in depth. The call in this example gets a description of a particular API proxy. Following a rest API pattern, we are now appending the name of the API to the previous call. You can see in the example that we're asking for information about the smartdocs proxy in the validate organization. The call returns created and modified times as well as the user involved in creation and modification. It also returns the name of the proxy and a revision number. Here, we can see the smartdocs proxy has two revisions. Next, we can see that to get information about a particular revision of a proxy, we simply append /revisions and the revision number to the previous call. This time, we get much more information about the smartdocs proxy. This is actually only a snippet of the full information, but the response contains the proxy base path, context information, all the policies the proxy implements, which endpoints it uses, in this case, default. The full information also includes target endpoints, a list of any resources the proxy uses, JavaScript, Python scripts, et cetera, as well as all the information seen in previous calls. In this final part, we look at how to export and import proxies. To export a proxy, we can use the call we just made to get information about the proxy revision. This time, however, we had the query parameters format equals bundle, and then specify a file name for the downloadable bundle. The call will execute and a bundle will be saved as a zip file containing XML descriptions of the proxy, policies, and targets, as well as associated resource files. To import a proxy, we perform a post, setting the content time to application octet-string, and providing the name of the zip file to be uploaded. Again, if you remember back to where we talked about scope, you can see from the URL that it's obvious that the proxy is being uploaded to a specific organization, in this case, validate. The action is import and we specify the desired name using the name parameter. If we import a new version of a proxy that already exists in the organization, it is automatically saved with a new revision number. This concludes this lesson. For more information, please browse our documentation at docs.apigee.com. And to get involved in the community, please visit community.apigee.com. Thank you.